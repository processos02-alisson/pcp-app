<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
</head>
<body class="min-h-screen bg-gray-100 antialiased">
<script>
    // ----------------------------------------------------
    // INÍCIO: CONFIGURAÇÃO FIREBASE (SUBSTITUA PELOS SEUS DADOS)
    // ----------------------------------------------------
    const firebaseConfig = {
        apiKey: "SUA_API_KEY",
        authDomain: "SEU_AUTH_DOMAIN",
        projectId: "SEU_PROJECT_ID",
        databaseURL: "SUA_DATABASE_URL", // Obrigatório para Realtime Database
        storageBucket: "SEU_STORAGE_BUCKET",
        messagingSenderId: "SEU_MESSAGING_SENDER_ID",
        appId: "SEU_APP_ID"
    };

    // Inicializa o Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const database = app.database();
    // ----------------------------------------------------
    // FIM: CONFIGURAÇÃO FIREBASE
    // ----------------------------------------------------

    // ==========================
    //  VARIÁVEIS E DADOS
    // ==========================
    const MASTER_PIN = "7889";
    const SECTORS = [
        'Corte','Corte de Revestimentos','Pré-Montagem','Preparação','Pré Conexão',
        'Conexão','Pré Grampeação','Grampeação','Acabamento','Embalagem','Montagem','Cabo de Bateria 1','Cabo de Bateria 2'
    ];
    const PAUSE_REASONS = [
        "Falta de material na bancada","Manutenção/Ajuste de máquina","Instrução de trabalho confusa/ausente",
        "Necessidade de assistência técnica","Troca de turno/intervalo programado","Outro (Detalhar abaixo)"
    ];
    const DELAY_REASONS = [
        "Complexidade inesperada da peça","Problema de qualidade na etapa anterior","Falta de treinamento/experiência",
        "Tempo padrão calculado incorretamente","Quebra/defeito de ferramenta","Outro (Detalhar abaixo)"
    ];

    let allOFs = {};
    let allTasks = {};
    let allRoteiros = {};
    let allOcurrencesLog = [];
    let currentAction = {};
    let currentSectorFilter = SECTORS[0];
    let currentUser = null;

    // Counters (agora só para inicialização, o Firebase gera IDs únicos)
    let roteiroCounter = 7; 

    // ==========================
    //  PERSISTÊNCIA (FIREBASE)
    // ==========================
    const DB_ROOT = 'pcp_system_data';

    // Funções de escrita/leitura
    async function saveStateToFirebase(data, path = DB_ROOT) {
        try {
            await database.ref(path).set(data);
            // console.log("Dados salvos com sucesso no Firebase:", path);
        } catch (e) {
            console.error("Falha ao salvar dados no Firebase:", e);
        }
    }
    
    // Função para salvar uma entidade específica
    async function saveEntity(entityType, key, data) {
        try {
            await database.ref(`${DB_ROOT}/${entityType}/${key}`).set(data);
        } catch (e) {
            console.error(`Falha ao salvar ${entityType} ${key}:`, e);
        }
    }

    // Função para carregar todos os dados
    async function loadAllData() {
        try {
            const snapshot = await database.ref(DB_ROOT).once('value');
            const data = snapshot.val() || {};

            allOFs = data.allOFs || {};
            allTasks = data.allTasks || {};
            allRoteiros = data.allRoteiros || {};
            allOcurrencesLog = data.allOcurrencesLog || [];

            // Apenas para garantir que o contador de roteiros seja maior que o último ID
            const roteiroKeys = Object.keys(allRoteiros);
            if (roteiroKeys.length > 0) {
                const maxId = roteiroKeys.reduce((max, key) => Math.max(max, parseInt(key.replace('r', '') || 0)), 0);
                roteiroCounter = maxId + 1;
            } else {
                // Se não houver roteiros, usa os defaults (lógica abaixo)
            }
            
            return true;
        } catch (e) {
            console.error("Falha ao carregar dados do Firebase:", e);
            return false;
        }
    }

    // A persistência do usuário continua local, pois é sobre a sessão no navegador
    function setUser(u){ currentUser = u; localStorage.setItem("pcp_current_user", JSON.stringify(u)); }
    function getUser(){ try{ return JSON.parse(localStorage.getItem("pcp_current_user")||"null"); }catch(e){ return null; } }


    // ==========================
    //  ROTEIROS PRÉ-CARREGADOS (Fallback)
    // ==========================
    const DEFAULT_ROTEIROS = {
        "r1": { id:"r1", chicote_nome:"CHICOTE-001", setor:"Corte", nome_atividade:"Corte dos Fios", tempo_setup:5, tempo_ciclo:0.2,
          instrucao_trabalho:"<b>1. Preparação:</b> Verifique se a faca está calibrada para o fio 1.0mm.<br><b>2. Medição:</b> Corte 50 peças com 150mm cada.<br><b>3. Conferência:</b> Faça uma conferência visual. <a href='https://upload.wikimedia.org/wikipedia/commons/4/4e/Sample_cut.png' target='_blank'>**Ver Imagem de Padrão**</a>."
        },
        "r2": { id:"r2", chicote_nome:"CHICOTE-001", setor:"Pré-Montagem", nome_atividade:"Crimpagem de Terminais", tempo_setup:8, tempo_ciclo:0.5,
          instrucao_trabalho:"<b>1. Fio Preto:</b> ...<br><b>2. Fio Vermelho:</b> ...<br><b>3. Teste:</b> > 10Kgf. <a href='https://www.youtube.com/watch?v=dQw4w9WgXcQ' target='_blank'>**Assistir Vídeo**</a>"
        },
        "r3": { id:"r3", chicote_nome:"CHICOTE-001", setor:"Montagem Final", nome_atividade:"Montagem de Conectores", tempo_setup:15, tempo_ciclo:1.0,
          instrucao_trabalho:"<b>Atenção:</b> Conectar posições 35 e 33. Proibido forçar."
        },
        "r4": { id:"r4", chicote_nome:"CHICOTE-001", setor:"Qualidade", nome_atividade:"Teste de Continuidade", tempo_setup:3, tempo_ciclo:0.1,
          instrucao_trabalho:"Usar jig JIG-10B. 100% devem passar."
        },
        "r5": { id:"r5", chicote_nome:"CHICOTE-B", setor:"Corte", nome_atividade:"Corte Fios Reforçados", tempo_setup:10, tempo_ciclo:0.3, instrucao_trabalho:"Instrução básica B."},
        "r6": { id:"r6", chicote_nome:"CHICOTE-B", setor:"Montagem Final", nome_atividade:"Montagem Simples", tempo_setup:5, tempo_ciclo:0.8, instrucao_trabalho:"Conectar 4 vias."},
    };

    // ==========================
    //  ELEMENTOS UI
    // ==========================
    const pcpView = document.getElementById("pcp-view");
    const operatorView = document.getElementById("operator-view");
    const reportView = document.getElementById("report-view");
    const loadingIndicator = document.getElementById("loading-indicator");
    const ofsListContainer = document.getElementById("ofs-list-container");
    const tasksListContainer = document.getElementById("tasks-list-container");
    const userViewSelect = document.getElementById("user-view-select");
    const btnCreateOF = document.getElementById("btn-create-of");
    const btnSetupRoteiro = document.getElementById("btn-setup-roteiro");
    const btnProfile = document.getElementById("btn-profile");
    const btnExportReport = document.getElementById("btn-export-report");

    // ==========================
    //  HELPERS & PERMISSÕES
    // ==========================
    function msToMinutes(ms){ return parseFloat((ms / (1000*60)).toFixed(2)); }
    function formatMinutes(v){ return `${Number(v||0).toFixed(2)} min`; }
    function isMaster(){ return currentUser && currentUser.role === "MASTER"; }
    function isOperador(){ return currentUser && currentUser.role === "OPERADOR"; }

    // ==========================
    //  CÁLCULOS DE TEMPO
    // ==========================
    function calculateTempoReal(task){
        let tempoReal = task.tempo_real_acumulado || 0;
        const now = Date.now();
        if (task.status === 'Em Processo' && task.timestamp_inicio){
            let inicioMs = task.timestamp_inicio instanceof Date ? task.timestamp_inicio.getTime() : task.timestamp_inicio;
            let tempoTrabalhadoDesdeInicio = msToMinutes(now - inicioMs);
            tempoReal += tempoTrabalhadoDesdeInicio;
        }
        return parseFloat(tempoReal.toFixed(2));
    }
    function calculateDesvio(task){
        const tempoReal = calculateTempoReal(task);
        const desvio = (task.tempo_planejado||0) - tempoReal;
        return parseFloat(desvio.toFixed(2));
    }
    function calculateTotalPauseMinutes(task){
        let totalMs = task.total_pause_time_ms || 0;
        if (task.status === 'Pausada' && task.pause_start_timestamp){
            totalMs += Date.now() - task.pause_start_timestamp;
        }
        return msToMinutes(totalMs);
    }

    // ==========================
    //  INICIALIZAÇÃO
    // ==========================
    function setupSectorDropdowns(){
        const roteiroSetorSelect = document.getElementById('roteiro-setor');
        const sectorFilterSelect = document.getElementById('sector-filter');
        if (roteiroSetorSelect) { roteiroSetorSelect.innerHTML = ''; }
        if (sectorFilterSelect) { sectorFilterSelect.innerHTML=''; }

        // Setup Roteiro
        if (roteiroSetorSelect) {
            SECTORS.forEach(sector=>{
                const o1 = document.createElement('option'); o1.value=sector; o1.textContent=sector; roteiroSetorSelect.appendChild(o1);
            });
        }

        // Operador vê apenas seu setor
        if (sectorFilterSelect){
            if (isOperador()){
                const o = document.createElement('option'); o.value=currentUser.sector; o.textContent=currentUser.sector; sectorFilterSelect.appendChild(o);
                sectorFilterSelect.value=currentUser.sector;
                sectorFilterSelect.disabled = true;
                currentSectorFilter = currentUser.sector;
            }else{
                SECTORS.forEach(sector=>{
                    const o2 = document.createElement('option'); o2.value=sector; o2.textContent=sector; sectorFilterSelect.appendChild(o2);
                });
                currentSectorFilter = SECTORS[0];
                sectorFilterSelect.value = SECTORS[0];
                sectorFilterSelect.disabled = false;
            }
        }
    }

    async function initializeApp(){
        // Aviso de simulação
        document.getElementById('loading-indicator').innerHTML = `
          <div class="p-3 sm:p-4 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded-lg shadow-md" role="alert">
            <p class="font-bold">Aviso: Modo de Execução com Persistência em Nuvem (Firebase)</p>
            <p class="text-xs sm:text-sm">Certifique-se de que suas credenciais do Firebase no código estejam corretas.</p>
          </div>`;
        document.getElementById('loading-indicator').classList.remove('hidden');

        // Restaura estado do Firebase
        const restored = await loadAllData(); 
        
        // Se a carga falhou ou não há dados, inicializa com defaults
        if (Object.keys(allRoteiros).length === 0){
            allRoteiros = { ...DEFAULT_ROTEIROS };
            // Cria duas OFs iniciais se o banco estiver vazio
            if (Object.keys(allOFs).length === 0) {
                createOF('OF-001', 10, 'CHICOTE-001', true);
                createOF('OF-002', 20, 'CHICOTE-B', true);
            }
            // Salva os defaults
            await saveStateToFirebase({ allRoteiros, allOFs, allTasks, allOcurrencesLog });
        }
        
        const savedUser = getUser();
        if (savedUser){ setUser(savedUser); }

        setTimeout(()=>{
            loadingIndicator.classList.add('hidden');
            openUserModal(savedUser ? null : undefined);
            setupUIRefresh();
        }, 300);
    }

    // ==========================
    //  KPI / RENDER
    // ==========================
    function reloadActiveFilter(){ /* placeholder */ }

    function renderKPIs(){
        const kpisContainer = document.getElementById('kpis-container');
        if (!kpisContainer) return;
        const totalOFs = Object.keys(allOFs).filter(k=> allOFs[k]?.status !== 'Concluído').length;
        const concludedTasks = Object.values(allTasks).filter(t=>t.status==='Concluído').length;
        const totalTasks = Object.values(allTasks).length;
        const totalPause = allOcurrencesLog.reduce((s,l)=> s + (l.TEMPO_PAUSA||0), 0);

        const kpiData = [
            { title:"OFs Ativas", value: totalOFs, icon:"package", color:"bg-blue-600" },
            { title:"Tarefas Concluídas", value: `${concludedTasks} / ${totalTasks}`, icon:"check-circle", color:"bg-green-600" },
            { title:"Pausas (min)", value: totalPause.toFixed(1), icon:"pause-circle", color:"bg-yellow-600" },
            { title:"Ocorrências", value: allOcurrencesLog.length, icon:"alert-triangle", color:"bg-red-600" },
        ];
        kpisContainer.innerHTML = kpiData.map(k=>`
            <div class="${k.color} text-white p-3 sm:p-4 rounded-xl shadow-md flex items-center justify-between">
                <div>
                    <p class="text-xs sm:text-sm font-medium opacity-80">${k.title}</p>
                    <p class="text-2xl sm:text-3xl font-bold">${k.value}</p>
                </div>
                <i data-lucide="${k.icon}" class="w-7 h-7 sm:w-8 sm:h-8 opacity-70"></i>
            </div>`).join('');
        lucide.createIcons();
    }

    function updateView(view){
        if (isOperador() && view !== 'Operador'){ view = 'Operador'; }

        const isPCP = view === 'PCP';
        const isReport = view === 'Relatorio';

        pcpView.classList.toggle('hidden', !isPCP);
        operatorView.classList.toggle('hidden', (isPCP || isReport));
        reportView.classList.toggle('hidden', !isReport);

        userViewSelect.value = view;
        btnCreateOF.classList.toggle('hidden', !isMaster());
        btnSetupRoteiro.classList.toggle('hidden', !isMaster());
        btnProfile.classList.remove('hidden');
        userViewSelect.disabled = isOperador();
        if (btnExportReport) btnExportReport.classList.toggle('hidden', !isMaster());

        if (isPCP){
            renderKPIs();
            renderOFs();
            reloadActiveFilter();
        } else if (view === 'Operador'){
            renderTasks();
        } else if (isReport){
            renderReport();
        }
        lucide.createIcons();
    }
    window.updateView = updateView;

    function renderReport(){
        const body = document.getElementById('report-table-body');
        if (allOcurrencesLog.length === 0){
            body.innerHTML = `<tr><td colspan="7" class="px-6 py-4 text-center text-sm text-gray-500">Nenhuma ocorrência registrada.</td></tr>`;
            return;
        }
        const html = allOcurrencesLog.map(log=>{
            const atrasoClass = (log.TEMPO_ATRASO||0) > 0 ? 'highlight-red' : 'text-gray-600';
            const pausaClass  = (log.TEMPO_PAUSA||0) > 0 ? 'text-yellow-700 font-semibold' : 'text-gray-600';
            return `
                <tr>
                    <td class="px-3 sm:px-6 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${log.OF}</td>
                    <td class="px-3 sm:px-6 py-2 whitespace-nowrap text-sm text-gray-600">${log.CHICOTE}</td>
                    <td class="px-3 sm:px-6 py-2 whitespace-nowrap text-sm text-gray-600">${log.ATIVIDADE}</td>
                    <td class="px-3 sm:px-6 py-2 text-sm text-gray-800">${log.MOTIVO_PAUSA || '-'}</td>
                    <td class="px-3 sm:px-6 py-2 text-sm text-gray-800">${log.MOTIVO_ATRASO || '-'}</td>
                    <td class="px-3 sm:px-6 py-2 whitespace-nowrap text-sm ${pausaClass}">${(log.TEMPO_PAUSA||0).toFixed(2)}</td>
                    <td class="px-3 sm:px-6 py-2 whitespace-nowrap text-sm ${atrasoClass}">${(log.TEMPO_ATRASO||0).toFixed(2)}</td>
                </tr>
            `;
        }).join('');
        body.innerHTML = html;
        lucide.createIcons();
    }

    function renderOFs(){
        const ofs = Object.values(allOFs).sort((a,b) => (a.status === 'Concluído' ? 1 : -1)); // Concluídas por último
        ofsListContainer.innerHTML = ofs.map(of=> {
            const tasks = Object.values(allTasks).filter(t => t.of_id === of.id);
            const totalTasks = tasks.length;
            const completedTasks = tasks.filter(t => t.status === 'Concluído').length;
            const progress = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

            let statusClass = "bg-blue-500";
            if (of.status === 'Concluído') statusClass = "bg-green-500";
            else if (progress > 0) statusClass = "bg-yellow-500";

            return `
                <div class="bg-white p-4 rounded-xl shadow-lg hover:shadow-xl transition cursor-pointer card-tap-big"
                     onclick="openOFDetailsModal('${of.id}')">
                    <div class="flex items-center justify-between mb-2 border-b pb-2">
                        <h3 class="text-lg font-bold text-gray-800">${of.id} (${of.chicote})</h3>
                        <span class="text-xs font-semibold px-2 py-1 rounded-full text-white ${statusClass}">
                            ${of.status}
                        </span>
                    </div>
                    <p class="text-sm text-gray-600 mb-3">Quantidade: <span class="font-semibold">${of.quantidade}</span> peças</p>
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div class="h-2 rounded-full ${statusClass}" style="width:${progress}%"></div>
                    </div>
                    <p class="text-xs text-gray-500 mt-1 text-right">${progress}% Completo (${completedTasks}/${totalTasks} Etapas)</p>
                </div>
            `;
        }).join('');
        lucide.createIcons();
    }

    function updateSectorFilter(sector){
        currentSectorFilter = sector;
        renderTasks();
    }
    window.updateSectorFilter = updateSectorFilter;

    function renderTasks(){
        const tasks = Object.values(allTasks)
            .filter(t => t.setor === currentSectorFilter && t.status !== 'Concluído')
            .sort((a, b) => a.of_id.localeCompare(b.of_id)); // Agrupa por OF

        tasksListContainer.innerHTML = '';
        if (tasks.length === 0){
            tasksListContainer.innerHTML = `
                <div class="p-6 bg-white rounded-xl shadow-md text-center text-gray-500">
                    <i data-lucide="clipboard-check" class="w-6 h-6 mx-auto mb-2"></i>
                    <p class="font-semibold">Nenhuma tarefa pendente para o setor de ${currentSectorFilter}.</p>
                </div>`;
            lucide.createIcons();
            return;
        }

        tasks.forEach(task => {
            const tempoReal = calculateTempoReal(task);
            const desvio = calculateDesvio(task);
            const desvioText = desvio <= 0 ? `<span class="text-green-600 font-semibold">${formatMinutes(desvio * -1)} à frente</span>` : `<span class="highlight-red">${formatMinutes(desvio)} de atraso</span>`;

            let actionButton = '';
            let cardClass = 'bg-white';
            let statusColor = 'text-gray-500';

            switch (task.status){
                case 'Pendente':
                    cardClass = 'bg-blue-50 border-l-4 border-blue-500';
                    statusColor = 'text-blue-600';
                    actionButton = `
                        <button onclick="startTask('${task.id}')" class="w-full sm:w-auto px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition">
                            <i data-lucide="play" class="w-4 h-4 inline-block mr-1"></i> Iniciar
                        </button>`;
                    break;
                case 'Em Processo':
                    cardClass = 'bg-yellow-50 border-l-4 border-yellow-500';
                    statusColor = 'text-yellow-600';
                    actionButton = `
                        <button onclick="openActionModal('${task.id}', 'pause')" class="w-full sm:w-auto px-4 py-2 bg-yellow-600 text-white font-semibold rounded-lg hover:bg-yellow-700 transition mb-2 sm:mb-0">
                            <i data-lucide="pause" class="w-4 h-4 inline-block mr-1"></i> Pausar
                        </button>
                        <button onclick="openActionModal('${task.id}', 'complete')" class="w-full sm:w-auto px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition">
                            <i data-lucide="check" class="w-4 h-4 inline-block mr-1"></i> Concluir
                        </button>`;
                    break;
                case 'Pausada':
                    cardClass = 'bg-red-50 border-l-4 border-red-500';
                    statusColor = 'text-red-600';
                    actionButton = `
                        <button onclick="unpauseTask('${task.id}')" class="w-full sm:w-auto px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition">
                            <i data-lucide="play" class="w-4 h-4 inline-block mr-1"></i> Retomar
                        </button>`;
                    break;
            }

            const card = document.createElement('div');
            card.className = `${cardClass} p-3 sm:p-5 rounded-xl shadow-md flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3`;
            card.innerHTML = `
                <div class="flex-grow min-w-0">
                    <p class="text-xs font-semibold mb-1 ${statusColor}">${task.status} | OF: ${task.of_id} (${task.chicote})</p>
                    <h3 class="text-lg font-bold text-gray-800 truncate">${task.nome_atividade}</h3>
                    <div class="mt-2 text-xs sm:text-sm text-gray-700 space-y-1">
                        <p>Tempo Padrão: <span class="font-semibold">${formatMinutes(task.tempo_planejado)}</span></p>
                        <p>Tempo Real: <span class="font-semibold">${formatMinutes(tempoReal)}</span></p>
                        <p>Desvio: ${desvioText}</p>
                    </div>
                    <button onclick="openInstructionModal('${task.id}')" class="mt-2 text-xs text-indigo-600 hover:text-indigo-800 font-semibold flex items-center">
                        <i data-lucide="book-open-text" class="w-4 h-4 mr-1"></i> Ver Instrução de Trabalho
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row gap-2 w-full sm:w-auto flex-shrink-0">
                    ${actionButton}
                </div>
            `;
            tasksListContainer.appendChild(card);
        });
        lucide.createIcons();
    }

    // ==========================
    //  MODAL ACTIONS
    // ==========================
    function openModal(id){
        document.getElementById(id).classList.add('flex');
        document.getElementById(id).classList.remove('hidden');
        if (id === 'setup-roteiro-modal') renderRoteiroSetup();
        if (id === 'create-of-modal') populateOFChicoteDropdown();
        // Garante que o corpo do modal principal esteja limpo
        if (id === 'action-modal') {
            document.getElementById('justification-area').classList.remove('hidden');
            document.getElementById('justification-required-text').classList.add('hidden');
        }
    }

    function closeModal(id = 'action-modal'){
        document.getElementById(id).classList.add('hidden');
        document.getElementById(id).classList.remove('flex');
    }
    window.closeModal = closeModal;


    // ACTION MODAL (Pause/Complete)
    function openActionModal(taskId, actionType){
        const task = allTasks[taskId];
        if (!task) return;

        currentAction = { taskId, actionType };
        let title, message, justificationOptions, buttonText;

        if (actionType === 'pause'){
            title = 'Pausar Atividade';
            message = `Você está pausando a atividade: **${task.nome_atividade}** (OF: ${task.of_id}). Selecione o motivo da pausa.`;
            justificationOptions = PAUSE_REASONS;
            buttonText = 'Confirmar Pausa';
        } else if (actionType === 'complete'){
            title = 'Concluir Atividade';
            message = `Você está concluindo a atividade: **${task.nome_atividade}** (OF: ${task.of_id}).`;
            justificationOptions = DELAY_REASONS;
            buttonText = 'Concluir e Próxima';
        }

        const desvio = calculateDesvio(task);
        const justificationArea = document.getElementById('justification-area');
        const requiredText = document.getElementById('justification-required-text');

        // Lógica de desvio: Se for atraso (desvio positivo) e a ação for concluir, o motivo é obrigatório
        if (actionType === 'complete' && desvio > 0) {
            justificationArea.classList.remove('hidden');
            requiredText.textContent = `🚨 Justificativa obrigatória: ${formatMinutes(desvio)} de atraso!`;
            requiredText.classList.remove('hidden');
        } else {
            // Se for pausa, é sempre bom ter a justificativa. Se for conclusão sem atraso, não é obrigatório.
            if (actionType === 'complete') {
                 justificationArea.classList.add('hidden'); // Oculta justificativa se não há atraso
            } else {
                 justificationArea.classList.remove('hidden');
                 requiredText.classList.add('hidden');
            }
        }

        // Popula o dropdown de motivos
        const select = document.getElementById('justification-select');
        select.innerHTML = '<option value="">-- Selecione uma opção --</option>' + justificationOptions.map(r => `<option value="${r}">${r}</option>`).join('');
        document.getElementById('justification-text').value = '';

        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-message').innerHTML = message;
        document.getElementById('modal-confirm-button').textContent = buttonText;
        document.getElementById('modal-confirm-button').classList.remove('bg-blue-600', 'bg-yellow-600', 'bg-green-600');
        document.getElementById('modal-confirm-button').classList.add(actionType === 'pause' ? 'bg-yellow-600' : 'bg-green-600');

        openModal('action-modal');
    }

    async function handleConfirmedAction(){
        const { taskId, actionType } = currentAction;
        const task = allTasks[taskId];

        const desvio = calculateDesvio(task);
        const justificationSelect = document.getElementById('justification-select').value;
        const justificationText = document.getElementById('justification-text').value.trim();
        const requiredText = document.getElementById('justification-required-text');

        // Validação de atraso
        if (actionType === 'complete' && desvio > 0 && !justificationSelect) {
            alert('🚨 O motivo do atraso é obrigatório! Selecione uma opção ou adicione detalhes.');
            return;
        }

        const fullJustification = justificationText ? `${justificationSelect} (${justificationText})` : justificationSelect;

        if (actionType === 'pause'){
            await pauseTask(taskId, fullJustification);
        } else if (actionType === 'complete'){
            await completeTask(taskId, fullJustification);
        }

        closeModal();
        renderTasks(); // Atualiza a visão do operador
        updateView(userViewSelect.value); // Atualiza a visão PCP/Relatório
    }
    window.handleConfirmedAction = handleConfirmedAction;

    // INSTRUCTION MODAL
    function openInstructionModal(taskId){
        const task = allTasks[taskId];
        if (!task) return;

        document.getElementById('instruction-modal-header').textContent = `Instrução para: ${task.chicote} - ${task.nome_atividade}`;
        document.getElementById('instruction-modal-content').innerHTML = task.instrucao_trabalho || "Nenhuma instrução detalhada fornecida para esta etapa.";

        openModal('instruction-modal');
    }

    // OF DETAILS MODAL
    window.__ofDetailsOpenId = null; // Guarda o ID da OF aberta para o botão de exportar
    function openOFDetailsModal(ofId){
        const of = allOFs[ofId];
        if (!of) return;
        window.__ofDetailsOpenId = ofId;

        const tasks = Object.values(allTasks).filter(t => t.of_id === ofId).sort((a, b) => (a.roteiro_id).localeCompare(b.roteiro_id));

        const totalTasks = tasks.length;
        const completedTasks = tasks.filter(t => t.status === 'Concluído').length;
        const progress = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
        let progressClass = of.status === 'Concluído' ? "bg-green-500" : "bg-blue-500";

        document.getElementById('of-details-title').textContent = `OF: ${of.id} (${of.chicote})`;
        document.getElementById('of-details-progress').style.width = `${progress}%`;
        document.getElementById('of-details-progress').className = `h-2 rounded-full ${progressClass}`;

        const totalPlannedTime = tasks.reduce((sum, t) => sum + (t.tempo_planejado || 0), 0).toFixed(2);
        const totalRealTime = tasks.reduce((sum, t) => sum + calculateTempoReal(t), 0).toFixed(2);
        const totalPauseTime = tasks.reduce((sum, t) => sum + calculateTotalPauseMinutes(t), 0).toFixed(2);

        document.getElementById('of-details-summary').innerHTML = `
            <div class="p-2 bg-gray-100 rounded-lg"><p class="text-xs text-gray-500">Qtd.</p><p class="font-semibold text-sm">${of.quantidade}</p></div>
            <div class="p-2 bg-gray-100 rounded-lg"><p class="text-xs text-gray-500">Progresso</p><p class="font-semibold text-sm">${progress}%</p></div>
            <div class="p-2 bg-gray-100 rounded-lg"><p class="text-xs text-gray-500">T. Padrão</p><p class="font-semibold text-sm">${totalPlannedTime} min</p></div>
            <div class="p-2 bg-gray-100 rounded-lg"><p class="text-xs text-gray-500">T. Real</p><p class="font-semibold text-sm">${totalRealTime} min</p></div>
        `;

        document.getElementById('of-details-content').innerHTML = tasks.map(task => {
            const tempoReal = calculateTempoReal(task);
            const desvio = calculateDesvio(task);
            const desvioColor = desvio <= 0 ? 'text-green-600' : 'highlight-red';
            const desvioSign = desvio <= 0 ? '' : '+';
            const totalPause = calculateTotalPauseMinutes(task);

            let statusColor = 'bg-gray-200 text-gray-600';
            if (task.status === 'Concluído') statusColor = 'bg-green-500 text-white';
            else if (task.status === 'Em Processo') statusColor = 'bg-yellow-500 text-white';
            else if (task.status === 'Pausada') statusColor = 'bg-red-500 text-white';
            else if (task.status === 'Pendente') statusColor = 'bg-blue-500 text-white';

            return `
                <div class="p-3 bg-white border border-gray-200 rounded-lg shadow-sm">
                    <div class="flex justify-between items-center mb-1">
                        <p class="text-base font-semibold text-gray-800">${task.nome_atividade} (<span class="font-normal text-sm text-gray-600">${task.setor}</span>)</p>
                        <span class="text-xs font-semibold px-2 py-1 rounded-full ${statusColor}">${task.status}</span>
                    </div>
                    <div class="grid grid-cols-2 sm:grid-cols-4 text-xs mt-2 gap-2">
                        <div><p class="text-gray-500">T. Padrão</p><p class="font-semibold">${formatMinutes(task.tempo_planejado)}</p></div>
                        <div><p class="text-gray-500">T. Real</p><p class="font-semibold">${formatMinutes(tempoReal)}</p></div>
                        <div><p class="text-gray-500">Desvio</p><p class="font-semibold ${desvioColor}">${desvioSign}${formatMinutes(desvio)}</p></div>
                        <div><p class="text-gray-500">T. Pausa</p><p class="font-semibold text-yellow-700">${formatMinutes(totalPause)}</p></div>
                    </div>
                </div>
            `;
        }).join('');

        openModal('of-details-modal');
    }
    window.openOFDetailsModal = openOFDetailsModal;


    // ==========================
    //  LÓGICA DO PCP / CRUD
    // ==========================

    // CREATE OF
    function createOF(id, quantity, chicote, isInitial=false){
        const ofId = id || document.getElementById('of-id').value.trim();
        const quantityStr = quantity || document.getElementById('of-quantity').value;
        const chicoteName = chicote || document.getElementById('of-chicote').value;
        const quantityNum = parseInt(quantityStr);

        const messageDiv = document.getElementById('of-creation-message');
        messageDiv.classList.add('hidden');

        if (!ofId || !quantityNum || !chicoteName) {
            messageDiv.textContent = 'Preencha todos os campos obrigatórios.';
            messageDiv.classList.remove('hidden');
            return;
        }
        if (allOFs[ofId]) {
            messageDiv.textContent = `OF com ID ${ofId} já existe.`;
            messageDiv.classList.remove('hidden');
            return;
        }

        const roteiroMaster = Object.values(allRoteiros).filter(r => r.chicote_nome === chicoteName);
        if (roteiroMaster.length === 0) {
            messageDiv.textContent = `Nenhum roteiro mestre encontrado para o chicote ${chicoteName}.`;
            messageDiv.classList.remove('hidden');
            return;
        }

        const newOF = {
            id: ofId,
            chicote: chicoteName,
            quantidade: quantityNum,
            status: 'Pendente', // Inicia Pendente
            timestamp_criacao: Date.now(),
        };

        allOFs[ofId] = newOF;
        
        // 2. Cria as Tasks
        roteiroMaster.forEach(roteiro => {
            const taskId = database.ref('temp-task-id').push().key; // Gera ID único para a task
            const tempoPlanejado = roteiro.tempo_setup + (roteiro.tempo_ciclo * quantityNum);
            
            const newTask = {
                id: taskId,
                of_id: ofId,
                roteiro_id: roteiro.id,
                chicote: chicoteName,
                setor: roteiro.setor,
                nome_atividade: roteiro.nome_atividade,
                tempo_planejado: parseFloat(tempoPlanejado.toFixed(2)),
                tempo_setup: roteiro.tempo_setup,
                tempo_ciclo: roteiro.tempo_ciclo,
                instrucao_trabalho: roteiro.instrucao_trabalho,
                status: 'Pendente',
                timestamp_inicio: null,
                timestamp_fim: null,
                tempo_real_acumulado: 0,
                total_pause_time_ms: 0,
                pause_start_timestamp: null,
            };
            allTasks[taskId] = newTask;
            
            // Salva a task no Firebase
            saveEntity('allTasks', taskId, newTask);
        });

        if (!isInitial) {
            closeModal('create-of-modal');
            alert(`OF ${ofId} gerada com sucesso! ${roteiroMaster.length} tarefas criadas.`);
        }
        
        // Salva a OF no Firebase e a lista de tarefas (para garantir consistência, embora tarefas já salvas)
        saveEntity('allOFs', ofId, newOF);
        updateView('PCP');
        
        return newOF;
    }
    window.createOF = createOF;

    // ROTEIRO SETUP
    function populateOFChicoteDropdown(){
        const chicoteSelect = document.getElementById('of-chicote');
        chicoteSelect.innerHTML = '<option value="">-- Selecione o Chicote --</option>';

        const chicotes = [...new Set(Object.values(allRoteiros).map(r => r.chicote_nome))];
        chicotes.forEach(chicote => {
            const option = document.createElement('option');
            option.value = chicote;
            option.textContent = chicote;
            chicoteSelect.appendChild(option);
        });
    }

    function renderRoteiroSetup(){
        const roteiroListDiv = document.getElementById('roteiro-list');
        roteiroListDiv.innerHTML = '';
        
        const roteirosByChicote = Object.values(allRoteiros).reduce((acc, roteiro) => {
            acc[roteiro.chicote_nome] = acc[roteiro.chicote_nome] || [];
            acc[roteiro.chicote_nome].push(roteiro);
            return acc;
        }, {});

        Object.keys(roteirosByChicote).sort().forEach(chicoteName => {
            const chicoteGroup = document.createElement('div');
            chicoteGroup.className = 'border p-3 rounded-lg bg-white shadow-sm';
            chicoteGroup.innerHTML = `<h5 class="text-base font-bold text-blue-800 mb-2">${chicoteName}</h5>`;

            roteirosByChicote[chicoteName].sort((a,b) => (a.id).localeCompare(b.id)).forEach(r => {
                const activityDiv = document.createElement('div');
                activityDiv.className = 'flex justify-between items-center py-1 border-t text-sm';
                activityDiv.innerHTML = `
                    <p class="text-gray-700">
                        <span class="font-semibold">${r.nome_atividade}</span> 
                        <span class="text-xs text-gray-500">(${r.setor})</span>
                    </p>
                    <div class="flex items-center gap-2">
                         <span class="text-xs text-gray-600">S: ${r.tempo_setup}m / C: ${r.tempo_ciclo}m</span>
                         <button onclick="deleteRoteiroActivity('${r.id}')" class="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100 transition">
                            <i data-lucide="x" class="w-4 h-4"></i>
                         </button>
                    </div>
                `;
                chicoteGroup.appendChild(activityDiv);
            });
            roteiroListDiv.appendChild(chicoteGroup);
        });
        lucide.createIcons();
    }

    async function addRoteiroActivity(){
        const chicoteName = document.getElementById('roteiro-chicote-name').value.trim().toUpperCase();
        const setor = document.getElementById('roteiro-setor').value;
        const activityName = document.getElementById('roteiro-activity-name').value.trim();
        const setupTime = parseFloat(document.getElementById('roteiro-setup-time').value);
        const cycleTime = parseFloat(document.getElementById('roteiro-cycle-time').value);
        const instructionText = document.getElementById('roteiro-instruction-text').value.trim();
        const messageDiv = document.getElementById('roteiro-message');
        messageDiv.textContent = '';

        if (!chicoteName || !setor || !activityName || isNaN(setupTime) || isNaN(cycleTime) || setupTime < 0 || cycleTime < 0) {
            messageDiv.textContent = 'Preencha o nome do chicote, setor, nome da atividade e tempos válidos.';
            return;
        }

        const newId = 'r' + roteiroCounter++;
        const newRoteiro = {
            id: newId,
            chicote_nome: chicoteName,
            setor: setor,
            nome_atividade: activityName,
            tempo_setup: setupTime,
            tempo_ciclo: cycleTime,
            instrucao_trabalho: instructionText,
        };
        allRoteiros[newId] = newRoteiro;
        
        // Salva e atualiza UI
        await saveEntity('allRoteiros', newId, newRoteiro);
        renderRoteiroSetup();

        // Limpa campos após sucesso
        document.getElementById('roteiro-activity-name').value = '';
        document.getElementById('roteiro-setup-time').value = '';
        document.getElementById('roteiro-cycle-time').value = '';
        document.getElementById('roteiro-instruction-text').value = '';
    }
    window.addRoteiroActivity = addRoteiroActivity;

    async function deleteRoteiroActivity(roteiroId){
        if (!confirm(`Tem certeza que deseja DELETAR o roteiro mestre ${allRoteiros[roteiroId].chicote_nome} - ${allRoteiros[roteiroId].nome_atividade}? Isso não afeta OFs existentes.`)) return;

        delete allRoteiros[roteiroId];
        
        // Remove do Firebase
        await database.ref(`${DB_ROOT}/allRoteiros/${roteiroId}`).remove();

        renderRoteiroSetup();
    }
    window.deleteRoteiroActivity = deleteRoteiroActivity;

    // TASK ACTIONS
    async function updateTaskAndOFStatus(taskId, updateData, isComplete = false){
        const task = allTasks[taskId];
        if (!task) return;

        // 1. Atualiza Task
        Object.assign(task, updateData);
        await saveEntity('allTasks', taskId, task);


        // 2. Atualiza status da OF se necessário
        const of = allOFs[task.of_id];
        if (!of) return;

        let totalTasks = Object.values(allTasks).filter(t => t.of_id === of.id).length;
        let pendingTasks = Object.values(allTasks).filter(t => t.of_id === of.id && t.status === 'Pendente').length;
        let inProcessTasks = Object.values(allTasks).filter(t => t.of_id === of.id && t.status === 'Em Processo').length;
        let concludedTasks = Object.values(allTasks).filter(t => t.of_id === of.id && t.status === 'Concluído').length;

        let newOFStatus = of.status;
        if (concludedTasks === totalTasks) {
            newOFStatus = 'Concluído';
        } else if (inProcessTasks > 0 || concludedTasks > 0) {
            newOFStatus = 'Em Andamento';
        } else {
            newOFStatus = 'Pendente';
        }

        if (newOFStatus !== of.status) {
            of.status = newOFStatus;
            if (newOFStatus === 'Concluído') of.timestamp_fim = Date.now();
            await saveEntity('allOFs', of.id, of);
        }
    }

    async function startTask(taskId){
        const task = allTasks[taskId];
        if (!task || task.status !== 'Pendente') return;

        await updateTaskAndOFStatus(taskId, {
            status: 'Em Processo',
            timestamp_inicio: Date.now(),
        });

        renderTasks();
        updateView('PCP');
    }
    window.startTask = startTask;

    async function unpauseTask(taskId){
        const task = allTasks[taskId];
        if (!task || task.status !== 'Pausada') return;

        const pauseDurationMs = Date.now() - task.pause_start_timestamp;
        const newTotalPauseMs = (task.total_pause_time_ms || 0) + pauseDurationMs;

        await updateTaskAndOFStatus(taskId, {
            status: 'Em Processo',
            pause_start_timestamp: null,
            total_pause_time_ms: newTotalPauseMs
        });

        renderTasks();
        updateView('PCP');
    }
    window.unpauseTask = unpauseTask;

    async function pauseTask(taskId, reason){
        const task = allTasks[taskId];
        if (!task || task.status !== 'Em Processo') return;

        // 1. Calcula o tempo real acumulado
        const tempoTrabalhadoAgora = msToMinutes(Date.now() - task.timestamp_inicio);
        const newTempoRealAcumulado = (task.tempo_real_acumulado || 0) + tempoTrabalhadoAgora;

        // 2. Cria Log de Ocorrência (Pausa)
        const totalPauseMinutes = calculateTotalPauseMinutes(task);
        const newLog = {
            TIMESTAMP: Date.now(),
            TIPO: 'PAUSA',
            OPERADOR_SETOR: currentUser.sector,
            OF: task.of_id,
            CHICOTE: task.chicote,
            ATIVIDADE: task.nome_atividade,
            MOTIVO_PAUSA: reason,
            TEMPO_PAUSA: totalPauseMinutes,
            TEMPO_ATRASO: 0, // Não se mede atraso em pausa
        };
        allOcurrencesLog.push(newLog);
        await saveEntity('allOcurrencesLog', allOcurrencesLog.length - 1, newLog);

        // 3. Atualiza Task para Pausada
        await updateTaskAndOFStatus(taskId, {
            status: 'Pausada',
            timestamp_inicio: null, // Reseta o contador de tempo de trabalho
            pause_start_timestamp: Date.now(),
            tempo_real_acumulado: parseFloat(newTempoRealAcumulado.toFixed(2))
        });
    }

    async function completeTask(taskId, reason){
        const task = allTasks[taskId];
        if (!task || (task.status !== 'Em Processo' && task.status !== 'Pendente')) return;

        // 1. Calcula o tempo real acumulado
        let finalTempoReal = task.tempo_real_acumulado || 0;
        if (task.status === 'Em Processo') {
            const tempoTrabalhadoAgora = msToMinutes(Date.now() - task.timestamp_inicio);
            finalTempoReal += tempoTrabalhadoAgora;
        }

        const desvio = (task.tempo_planejado || 0) - finalTempoReal;
        const tempoAtraso = desvio < 0 ? parseFloat((desvio * -1).toFixed(2)) : 0;

        // 2. Cria Log de Ocorrência (Atraso) se houver
        if (tempoAtraso > 0 || task.total_pause_time_ms > 0) {
            const totalPauseMinutes = calculateTotalPauseMinutes(task);
            const newLog = {
                TIMESTAMP: Date.now(),
                TIPO: tempoAtraso > 0 ? 'ATRASO' : 'INFO',
                OPERADOR_SETOR: currentUser.sector,
                OF: task.of_id,
                CHICOTE: task.chicote,
                ATIVIDADE: task.nome_atividade,
                MOTIVO_ATRASO: tempoAtraso > 0 ? reason : null,
                MOTIVO_PAUSA: totalPauseMinutes > 0 ? 'Pausa registrada durante a tarefa' : null,
                TEMPO_ATRASO: tempoAtraso,
                TEMPO_PAUSA: totalPauseMinutes,
            };
            allOcurrencesLog.push(newLog);
            await saveEntity('allOcurrencesLog', allOcurrencesLog.length - 1, newLog);
        }

        // 3. Atualiza Task para Concluída
        await updateTaskAndOFStatus(taskId, {
            status: 'Concluído',
            timestamp_inicio: null,
            timestamp_fim: Date.now(),
            tempo_real_acumulado: finalTempoReal,
            pause_start_timestamp: null,
        }, true);
    }

    // ==========================
    //  USUÁRIO / LOGIN
    // ==========================
    function openUserModal(force = false){
        const savedUser = getUser();
        if (!force && savedUser) return;

        const roleSelect = document.getElementById('user-role');
        const sectorSelect = document.getElementById('user-sector');
        const pinWrap = document.getElementById('user-pin-wrap');
        const sectorWrap = document.getElementById('user-sector-wrap');

        // Popula setor para login
        sectorSelect.innerHTML = SECTORS.map(s => `<option value="${s}">${s}</option>`).join('');

        // Listener para alternar PIN e Setor
        roleSelect.onchange = () => {
            if (roleSelect.value === 'MASTER'){
                pinWrap.classList.remove('hidden');
                sectorWrap.classList.add('hidden');
            } else {
                pinWrap.classList.add('hidden');
                sectorWrap.classList.remove('hidden');
            }
        };
        // Estado inicial
        roleSelect.dispatchEvent(new Event('change'));

        openModal('user-modal');
    }
    window.openUserModal = openUserModal;

    function confirmUser(){
        const role = document.getElementById('user-role').value;
        const pin = document.getElementById('user-pin').value;
        const sector = document.getElementById('user-sector').value;

        if (role === 'MASTER'){
            if (pin !== MASTER_PIN){
                alert('PIN Master incorreto.');
                return;
            }
            setUser({ role: 'MASTER', sector: null });
        } else {
            setUser({ role: 'OPERADOR', sector: sector });
        }

        closeModal('user-modal');
        setupSectorDropdowns();
        updateView(role === 'MASTER' ? 'PCP' : 'Operador');
    }
    window.confirmUser = confirmUser;

    // ==========================
    //  LOOP E EXPORTAÇÃO
    // ==========================
    function setupUIRefresh(){
        setInterval(() => {
            // Apenas atualiza o render de tarefas se a view do operador estiver visível
            if (!operatorView.classList.contains('hidden')) {
                renderTasks();
            }
            // Apenas atualiza o render de OFs se a view PCP estiver visível
            if (!pcpView.classList.contains('hidden')) {
                renderOFs();
                renderKPIs();
            }
            // Atualiza o modal de detalhes da OF se estiver aberto
            if (!document.getElementById('of-details-modal').classList.contains('hidden') && window.__ofDetailsOpenId) {
                 openOFDetailsModal(window.__ofDetailsOpenId);
            }
        }, 5000); // Atualiza a cada 5 segundos para calcular tempo real/desvio
    }

    function arrayToCSV(arr) {
        if (arr.length === 0) return '';
        const header = Object.keys(arr[0]).join(',');
        const rows = arr.map(obj => Object.values(obj).map(val => {
            if (typeof val === 'string') return `"${val.replace(/"/g, '""')}"`;
            return val;
        }).join(','));
        return [header, ...rows].join('\n');
    }

    function exportReportCSV() {
        if (allOcurrencesLog.length === 0) {
            alert("Nenhuma ocorrência para exportar.");
            return;
        }
        const logData = allOcurrencesLog.map(log => ({
            TIMESTAMP: new Date(log.TIMESTAMP).toLocaleString(),
            TIPO: log.TIPO,
            OPERADOR_SETOR: log.OPERADOR_SETOR,
            OF: log.OF,
            CHICOTE: log.CHICOTE,
            ATIVIDADE: log.ATIVIDADE,
            MOTIVO_PAUSA: log.MOTIVO_PAUSA || '-',
            MOTIVO_ATRASO: log.MOTIVO_ATRASO || '-',
            TEMPO_PAUSA_MIN: log.TEMPO_PAUSA || 0,
            TEMPO_ATRASO_MIN: log.TEMPO_ATRASO || 0,
        }));
        
        const csv = arrayToCSV(logData);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        if (link.download !== undefined) { 
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `relatorio_ocorrencias_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
    window.exportReportCSV = exportReportCSV;

    function exportOFTasksCSV(ofId) {
        const tasks = Object.values(allTasks).filter(t => t.of_id === ofId).map(task => ({
            OF: task.of_id,
            CHICOTE: task.chicote,
            ATIVIDADE: task.nome_atividade,
            SETOR: task.setor,
            STATUS: task.status,
            T_PLANEJADO_MIN: task.tempo_planejado,
            T_REAL_MIN: calculateTempoReal(task),
            DESVIO_MIN: calculateDesvio(task) * -1, // Positivo para atraso
            T_SETUP_MIN: task.tempo_setup,
            T_CICLO_MIN: task.tempo_ciclo,
            TIMESTAMP_INICIO: task.timestamp_inicio ? new Date(task.timestamp_inicio).toLocaleString() : '-',
            TIMESTAMP_FIM: task.timestamp_fim ? new Date(task.timestamp_fim).toLocaleString() : '-',
            INSTRUCAO: task.instrucao_trabalho.replace(/<[^>]*>?/gm, ''), // Remove HTML
        }));

        if (tasks.length === 0) {
            alert("Nenhuma tarefa para esta OF.");
            return;
        }
        
        const csv = arrayToCSV(tasks);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        if (link.download !== undefined) { 
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `detalhes_of_${ofId}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
    window.exportOFTasksCSV = exportOFTasksCSV;

    // INICIA APLICAÇÃO
    document.addEventListener('DOMContentLoaded', initializeApp);
</script>
</body>
</html>
